/**
 * script.js - Frontend logic for Code Starter AI
 */

// --- Global Application State ---
const AppState = {
    isLoading: false,
    isInitialState: true,
    availableModels: {},
    activeEditor: 'html-code',
    readmeContent: `# Project\n\nGenerated by Code Starter AI.\n\n*   index.html\n*   style.css\n*   script.js\n\nPlease review the generated code.`,
    currentAbortController: null, // To manage cancellation
};

// --- Cached DOM References ---
const DOM = {};

/**
 * Caches key DOM elements and logs any missing elements.
 * @returns {boolean} true if all essential elements are found, false otherwise.
 */
function cacheDOMElements() {
    console.log("Caching DOM Elements...");
    let foundAll = true;

    // Helper: Select a single element and record it in DOM
    const selectAndCheck = (key, selector, isId = true) => {
        try {
            const element = isId ? document.getElementById(selector) : document.querySelector(selector);
            DOM[key] = element;
            if (!element) {
                console.error(`FAILED to find element: Key='${key}', Selector='${isId ? '#' : ''}${selector}'`);
                foundAll = false;
            }
            return element;
        } catch (e) {
            console.error(`ERROR selecting element: Key='${key}', Selector='${selector}', Error: ${e.message}`);
            foundAll = false;
            DOM[key] = null;
            return null;
        }
    };

    // Helper: Select multiple elements and record the NodeList in DOM
    const selectAllAndCheck = (key, selector) => {
        try {
            const elements = document.querySelectorAll(selector);
            DOM[key] = elements;
            if (!elements || elements.length === 0) {
                console.warn(`Found 0 elements: Key='${key}', Selector='${selector}'`);
                // Not necessarily an error, might be optional elements
            }
            return elements;
        } catch (e) {
            console.error(`ERROR selecting elements: Key='${key}', Selector='${selector}', Error: ${e.message}`);
            foundAll = false; // Treat this as an error for critical selectors
            DOM[key] = [];
            return [];
        }
    };

    // Cache individual elements using the helpers
    selectAndCheck('appContainer', '.app-container', false);
    selectAndCheck('appHeader', '.app-header', false);
    selectAndCheck('initialLayoutWrapper', '.initial-layout-wrapper', false); // Added for clarity
    selectAndCheck('initialContent', '.initial-content', false);
    selectAndCheck('mainViewArea', '.main-view-area', false);
    selectAndCheck('promptInput', 'prompt-input', true);
    selectAndCheck('generateButton', 'generate-button', true);
    selectAndCheck('providerSelect', 'provider-select', true);
    selectAndCheck('modelSelect', 'model-select', true);
    selectAndCheck('addModelsButton', 'add-models-button', true);
    selectAndCheck('loadingIndicator', 'loading', true);
    selectAndCheck('errorMessageDiv', 'error-message', true);
    selectAndCheck('footerNoteBottom', '.footer-note-bottom', false);
    selectAndCheck('previewFrame', 'preview-frame', true);
    selectAndCheck('editorPane', 'editor-split-pane', true);
    selectAndCheck('previewPane', 'preview-split-pane', true);
    selectAndCheck('mainContentArea', '.main-content', false);
    selectAndCheck('htmlCodeArea', 'html-code', true);
    selectAndCheck('cssCodeArea', 'css-code', true);
    selectAndCheck('jsCodeArea', 'js-code', true);
    selectAndCheck('readmeArea', 'readme-content', true);
    selectAndCheck('codeEditorsContainer', '.code-editors', false);
    selectAndCheck('tabContainer', '.file-tabs', false); // Changed from 'file-tabs-container' ID to class selector
    selectAndCheck('downloadHtmlButton', 'download-html-button', true);
    selectAndCheck('downloadCssButton', 'download-css-button', true);
    selectAndCheck('downloadJsButton', 'download-js-button', true);
    selectAndCheck('downloadReadmeButton', 'download-readme-button', true);
    selectAndCheck('downloadZipButton', 'download-zip-button', true);
    selectAllAndCheck('allDownloadButtons', '.download-button'); // Corrected selector to class

    // Cache fullscreen button icons if available
    const fsButton = selectAndCheck('fullscreenButton', 'fullscreen-preview-button', true);
    if (fsButton) {
        DOM.fsIconExpand = fsButton.querySelector('.icon-expand');
        DOM.fsIconCollapse = fsButton.querySelector('.icon-collapse');
        if (!DOM.fsIconExpand) {
            console.error("FAILED to find element: fsIconExpand ('.icon-expand' within fullscreenButton)");
            foundAll = false; // Treat missing icons as potential error if button exists
        }
        if (!DOM.fsIconCollapse) {
            console.error("FAILED to find element: fsIconCollapse ('.icon-collapse' within fullscreenButton)");
            foundAll = false; // Treat missing icons as potential error if button exists
        }
    } else {
        // If the button itself is missing, icons won't be found, which is expected.
        DOM.fsIconExpand = null;
        DOM.fsIconCollapse = null;
        // Do not set foundAll to false here unless fullscreenButton is considered essential
    }
    DOM.body = document.body; // Always available

    console.log(`Finished caching DOM. All essential elements found: ${foundAll}`);
    return foundAll;
}

// --- Application Initialization ---
document.addEventListener('DOMContentLoaded', initializeApp);

/**
 * Main initialization function.
 * Caches DOM elements, validates critical elements, and sets up event listeners and UI.
 */
function initializeApp() {
    console.log("Initializing App...");
    if (!cacheDOMElements()) {
        // Attempt to show an error even if some elements are missing
        const errorDiv = document.getElementById('error-message');
        const msg = "App critical error: Essential UI components not found. Check console.";
        if (errorDiv) {
            errorDiv.textContent = msg;
            errorDiv.classList.remove('hidden');
        } else {
            alert(msg);
        }
        console.error("Initialization halted: Missing elements during cache.");
        return;
    }
    if (!checkEssentialElements()) {
        console.error("Initialization halted: Verification of essential elements failed.");
        // Error already shown by checkEssentialElements
        return;
    }
    console.log("Essential elements verified.");

    // Set initial state class
    DOM.appContainer?.classList.add('initial-state');
    AppState.isInitialState = true;
    if (DOM.modelSelect) DOM.modelSelect.disabled = true; // Ensure model select starts disabled

    checkJSZipAndSetupButton();
    setupEventListeners();
    setupSplitPane();
    fetchModelsAndPopulate();
    initializeEditors();
    setupFullscreenEvents();
    updateFullscreenButtonVisuals(); // Set initial button state
    autoResizePromptTextarea(); // Initial resize if needed

    console.log("App initialized successfully.");
}

/**
 * Verifies that all critical UI components are cached.
 * @returns {boolean} true if all critical elements are present.
 */
function checkEssentialElements() {
    console.log("Verifying essential elements...");
    const critical = {
        appContainer: DOM.appContainer,
        mainViewArea: DOM.mainViewArea,
        promptInput: DOM.promptInput,
        generateButton: DOM.generateButton,
        providerSelect: DOM.providerSelect,
        modelSelect: DOM.modelSelect,
        previewFrame: DOM.previewFrame,
        htmlCodeArea: DOM.htmlCodeArea,
        cssCodeArea: DOM.cssCodeArea, // Added CSS/JS as essential for functionality
        jsCodeArea: DOM.jsCodeArea,
        loadingIndicator: DOM.loadingIndicator,
        errorMessageDiv: DOM.errorMessageDiv,
        mainContentArea: DOM.mainContentArea,
        editorPane: DOM.editorPane,
        previewPane: DOM.previewPane,
        tabContainer: DOM.tabContainer, // Added as essential for navigation
        codeEditorsContainer: DOM.codeEditorsContainer // Added as essential
    };
    let allFound = true;
    for (const [key, el] of Object.entries(critical)) {
        if (!el) {
            console.error(`Verification failed: Essential element '${key}' not found.`);
            allFound = false;
        }
    }
    if (!allFound) {
        const errorMsg = "Core UI components missing. Application cannot start correctly.";
        // Use showError if available, otherwise alert
        if (DOM.errorMessageDiv) showError(errorMsg);
        else alert(errorMsg);
        console.error("Verification failed: Missing critical elements.");
    } else {
        console.log("All critical elements verified successfully.");
    }
    return allFound;
}


/** Checks if JSZip is loaded and disables the ZIP button if not. */
function checkJSZipAndSetupButton() {
    if (typeof JSZip === 'undefined') {
        console.warn("JSZip library is not loaded. ZIP download will be disabled.");
        if (DOM.downloadZipButton) {
            DOM.downloadZipButton.disabled = true;
            DOM.downloadZipButton.title = "ZIP functionality unavailable (library missing)";
            DOM.downloadZipButton.style.opacity = '0.6';
            DOM.downloadZipButton.style.cursor = 'not-allowed';
        }
    } else {
        console.log("JSZip library loaded successfully.");
    }
}

/** Sets up the Split.js pane for the editor and preview areas. */
function setupSplitPane() {
    // Check if Split library and required elements are present
    if (typeof Split === 'undefined') {
        console.warn("Split.js library not loaded. Split pane functionality disabled.");
        return;
    }
    if (!DOM.editorPane || !DOM.previewPane) {
        console.warn("Split pane elements (#editor-split-pane or #preview-split-pane) not found. Split functionality disabled.");
        return;
    }

    // Check window width - disable split on small screens if desired (using CSS instead is often better)
    if (window.innerWidth <= 768) {
        console.log("Screen width <= 768px, Split.js vertical layout handled by CSS.");
        // Don't initialize Split.js here, let CSS handle flex-direction: column
        // Ensure elements have appropriate height/min-height in CSS media query
        DOM.editorPane.style.flexBasis = ''; // Remove basis set by Split.js if any
        DOM.previewPane.style.flexBasis = '';
        return;
    }


    try {
        console.log("Initializing Split.js...");
        Split(['#editor-split-pane', '#preview-split-pane'], {
            sizes: [55, 45],      // Initial sizes percentage
            minSize: 200,         // Minimum size in pixels for both panes
            gutterSize: 8,        // Size of the gutter in pixels
            cursor: 'col-resize', // Cursor style when hovering over gutter
            // Use elementStyle and gutterStyle for flex-basis compatibility
            elementStyle: (dimension, size, gutterSize) => ({
                'flex-basis': `calc(${size}% - ${gutterSize / 2}px)`,
            }),
            gutterStyle: (dimension, gutterSize) => ({
                'flex-basis': `${gutterSize}px`,
            }),
            // Optional: Add callbacks for drag events if needed
            // onDragStart: () => console.log('Drag Start'),
            // onDragEnd: (sizes) => console.log('Drag End', sizes),
        });
        console.log("Split.js initialized successfully.");
    } catch (e) {
        console.error("Error initializing Split.js:", e);
        showError("Failed to initialize split view.");
    }
}

/** Attaches event listeners to UI elements. */
function setupEventListeners() {
    console.log("Setting up event listeners...");

    DOM.generateButton?.addEventListener('click', handleGenerateClick);
    DOM.providerSelect?.addEventListener('change', handleProviderChange);
    DOM.promptInput?.addEventListener('input', autoResizePromptTextarea);
    DOM.promptInput?.addEventListener('keydown', handlePromptKeyDown);

    // Debounced preview update for code areas
    const debouncedUpdatePreview = debounce(updatePreview, 350);
    DOM.htmlCodeArea?.addEventListener('input', debouncedUpdatePreview);
    DOM.cssCodeArea?.addEventListener('input', debouncedUpdatePreview);
    DOM.jsCodeArea?.addEventListener('input', debouncedUpdatePreview);

    // Tab switching
    DOM.tabContainer?.addEventListener('click', (e) => {
        if (e.target && e.target.classList.contains('file-tab-button')) {
            const targetEditorId = e.target.getAttribute('data-target-editor');
            if (targetEditorId) {
                setActiveTab(targetEditorId);
            }
        }
    });

    // Download buttons
    DOM.downloadHtmlButton?.addEventListener('click', () => downloadFile('index.html', DOM.htmlCodeArea?.value, 'text/html'));
    DOM.downloadCssButton?.addEventListener('click', () => downloadFile('style.css', DOM.cssCodeArea?.value, 'text/css'));
    DOM.downloadJsButton?.addEventListener('click', () => downloadFile('script.js', DOM.jsCodeArea?.value, 'text/javascript'));
    DOM.downloadReadmeButton?.addEventListener('click', () => downloadFile('README.md', DOM.readmeArea?.value, 'text/markdown'));
    DOM.downloadZipButton?.addEventListener('click', () => {
        if (typeof JSZip !== 'undefined') {
            handleDownloadZip();
        } else {
            showError('ZIP library is not available.');
            console.warn("Attempted ZIP download without JSZip loaded.");
        }
    });

    // Fullscreen button
    DOM.fullscreenButton?.addEventListener('click', toggleFullScreenPreview);

    // Optional: Listener for window resize to potentially re-initialize or adjust Split.js
    // window.addEventListener('resize', debounce(() => {
    //     console.log("Window resized");
    //     // Potentially re-run setupSplitPane logic if needed, carefully to avoid duplicates
    // }, 250));

    console.log("Event listeners set up.");
}

/** Sets up fullscreen change event listeners. */
function setupFullscreenEvents() {
    console.log("Setting up fullscreen event listeners...");
    const fullscreenEvents = [
        'fullscreenchange',
        'webkitfullscreenchange',
        'mozfullscreenchange',
        'MSFullscreenChange'
    ];
    fullscreenEvents.forEach(evt => {
        document.addEventListener(evt, handleFullscreenChange);
    });
    console.log("Fullscreen event listeners set up.");
}

/** Initializes the editors with default content and sets the active tab. */
function initializeEditors() {
    console.log("Initializing editors...");
    if (DOM.readmeArea) {
        // Use the default README content from AppState
        DOM.readmeArea.value = AppState.readmeContent;
    } else {
        console.warn("README textarea not found during editor initialization.");
    }
    // Set the initial active tab (e.g., HTML)
    setActiveTab('html-code'); // Make sure 'html-code' is a valid data-target-editor value
    console.log("Editors initialized.");
}

/** Automatically adjusts the height of the prompt textarea based on content. */
function autoResizePromptTextarea() {
    if (DOM.promptInput) {
        // Reset height to auto to correctly calculate scrollHeight
        DOM.promptInput.style.height = 'auto';
        // Set the height to the scroll height, but respect max-height from CSS
        const scrollHeight = DOM.promptInput.scrollHeight;
        // Get max-height style (e.g., '20vh' or '150px')
        const maxHeightStyle = window.getComputedStyle(DOM.promptInput).maxHeight;

        if (maxHeightStyle && maxHeightStyle !== 'none') {
            // Convert max-height to pixels if it's not already
            let maxHeightPx;
            if (maxHeightStyle.endsWith('px')) {
                maxHeightPx = parseFloat(maxHeightStyle);
            } else if (maxHeightStyle.endsWith('vh')) {
                maxHeightPx = parseFloat(maxHeightStyle) / 100 * window.innerHeight;
            } // Add other units like 'rem', 'em' if needed
            else {
                maxHeightPx = Infinity; // Fallback if unit is unrecognized
            }

            // Apply the scrollHeight or maxHeightPx, whichever is smaller
            DOM.promptInput.style.height = `${Math.min(scrollHeight, maxHeightPx)}px`;
        } else {
            // No max-height set, just use scrollHeight
            DOM.promptInput.style.height = `${scrollHeight}px`;
        }
    }
}

/** Handles keydown events on the prompt textarea (e.g., Enter to submit). */
function handlePromptKeyDown(event) {
    // Submit on Enter (if not Shift+Enter) and if not currently loading
    if (event.key === 'Enter' && !event.shiftKey && !AppState.isLoading) {
        event.preventDefault(); // Prevent default Enter behavior (new line)
        console.log("Enter pressed in prompt, triggering generation.");
        handleGenerateClick();
    }
}

/** Sets the active editor tab and updates UI accordingly. */
function setActiveTab(targetEditorId) {
    if (!targetEditorId) {
        console.warn("setActiveTab called with no targetId.");
        return;
    }
    if (!DOM.tabContainer || !DOM.codeEditorsContainer) {
        console.error("Cannot set active tab: Tab container or code editors container not found.");
        return;
    }

    console.log(`Setting active tab to: ${targetEditorId}`);
    AppState.activeEditor = targetEditorId;

    // Update tab buttons visual state
    DOM.tabContainer.querySelectorAll('.file-tab-button').forEach(button => {
        button.classList.toggle('active', button.getAttribute('data-target-editor') === targetEditorId);
    });

    // Show the corresponding editor wrapper and hide others
    let foundEditor = false;
    Array.from(DOM.codeEditorsContainer.children).forEach(wrapper => {
        if (wrapper.classList.contains('code-editor-wrapper')) {
            const editorId = wrapper.getAttribute('data-editor-id');
            const isActive = (editorId === targetEditorId);
            wrapper.classList.toggle('active', isActive);
            // Optional: Add aria-hidden for accessibility
            wrapper.setAttribute('aria-hidden', !isActive);
            if (isActive) {
                foundEditor = true;
                // Optional: Focus the corresponding textarea
                // wrapper.querySelector('.code-input')?.focus();
            }
        }
    });

    if (!foundEditor) {
        console.warn(`No editor wrapper found for targetId: ${targetEditorId}`);
        // Fallback: maybe activate the first tab?
        // setActiveTab('html-code'); // Be careful with recursion
    }
}

/** Handles the Generate button click: validates input, calls API, handles response. */
async function handleGenerateClick() {
    console.log("Handle Generate Click triggered.");
    if (AppState.isLoading) {
        console.log("Generation already in progress. Ignoring click.");
        return;
    }
    if (!DOM.promptInput || !DOM.providerSelect || !DOM.modelSelect || !DOM.generateButton) {
        console.error("Cannot generate: Essential input elements missing.");
        showError("Internal error: Input elements missing.");
        return;
    }

    const prompt = DOM.promptInput.value.trim();
    const provider = DOM.providerSelect.value;
    const model = DOM.modelSelect.value;

    // Input validation
    if (!provider) {
        showError("Please select a Provider.");
        DOM.providerSelect.focus();
        return;
    }
    if (!model) {
        showError("Please select a Model.");
        DOM.modelSelect.focus();
        return;
    }
    if (!prompt) {
        showError("Please enter a description of what you want to build.");
        DOM.promptInput.focus();
        return;
    }

    // Cancel any previous request if it exists
    cancelCurrentGeneration();
    AppState.currentAbortController = new AbortController();
    const signal = AppState.currentAbortController.signal;

    // Transition UI from initial state if necessary
    if (AppState.isInitialState) {
        console.log("First generation: Transitioning UI from initial state.");
        DOM.appContainer?.classList.remove('initial-state');
        AppState.isInitialState = false;
        // Optional: Small delay before showing loading to allow animation
        // await new Promise(resolve => setTimeout(resolve, 100));
    }

    setLoadingState(true);
    clearEditors(); // Clear previous results
    if (DOM.previewFrame) {
        // Update preview to show loading state
        DOM.previewFrame.srcdoc = '<!DOCTYPE html><html><head><title>Loading...</title><style>body{display:flex;justify-content:center;align-items:center;height:100vh;font-family:sans-serif;color:#555;}div{padding:20px;border:1px solid #ccc;border-radius:5px;}</style></head><body><div>Generating code...</div></body></html>';
    }

    let errorOccurred = false; // Flag to track if an error happened in this specific attempt
    try {
        console.log(`Sending generation request for provider: ${provider}, model: ${model}`);
        const response = await fetch('/generate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json' // Expect JSON response
            },
            body: JSON.stringify({ provider, modelName: model, prompt }),
            signal // Pass the abort signal
        });

        console.log(`Received response status: ${response.status}`);

        if (signal.aborted) {
            // Even if fetch completes, check if cancellation happened during processing
            throw new DOMException('Request cancelled by user.', 'AbortError');
        }

        if (!response.ok) {
            let errorMsg = `Server error: ${response.status} ${response.statusText}`;
            let errorDetails = null;
            try {
                // Try to parse error details from the response body
                errorDetails = await response.json();
                if (errorDetails && errorDetails.error) {
                    errorMsg = errorDetails.error; // Use specific error from JSON if available
                } else {
                    // Fallback: try to read as text if not JSON
                    const textError = await response.text();
                    if (textError && textError.length < 200) { // Avoid huge HTML error pages
                        errorMsg = textError;
                    }
                }
            } catch (e) {
                console.warn("Could not parse error response body:", e);
                // Attempt to read as text if JSON parsing failed
                try {
                    const textError = await response.text();
                    if (textError && textError.length < 200) { errorMsg = textError; }
                } catch (_) { /* Ignore further errors */ }
            }
            throw new Error(errorMsg); // Throw an error to be caught below
        }

        // Process successful response
        const result = await response.json();

        if (signal.aborted) {
            throw new DOMException('Request cancelled by user.', 'AbortError');
        }

        // Validate the structure of the successful response
        if (result && typeof result.html === 'string' && typeof result.css === 'string' && typeof result.js === 'string') {
            console.log("Generation successful. Populating editors.");
            populateEditors(result); // Fill editors with the new code
        } else {
            console.error("Invalid response structure received from API:", result);
            throw new Error("Received incomplete or invalid data from the server.");
        }

    } catch (error) {
        errorOccurred = true; // Flag that an error happened
        if (error.name === 'AbortError') {
            console.log('Generation request cancelled.');
            // Optionally show a less prominent "Cancelled" message or none
            // showError('Generation cancelled.'); // Can be too intrusive if user cancels intentionally
        } else {
            console.error('Error during code generation:', error);
            // Use the specific error message if available
            showError(error.message || 'Code generation failed. Please try again.');
        }
    } finally {
        setLoadingState(false); // Turn off loading indicator, re-enable inputs
        AppState.currentAbortController = null; // Clear the controller reference

        // *** ADDED FIX: Only hide error if no error occurred in *this* attempt ***
        if (!errorOccurred) {
            hideError();
        }
        // *** END OF FIX ***

        // Update the preview regardless of success/error,
        // as even on error, the previous state might need rendering
        // or the partial state might be relevant.
        updatePreview();
        console.log("Generation process finished.");
    }
}


/** Cancels any ongoing fetch request for code generation. */
function cancelCurrentGeneration() {
    if (AppState.currentAbortController) {
        console.log("Aborting current generation request...");
        AppState.currentAbortController.abort(); // Trigger the abort signal
        AppState.currentAbortController = null; // Clear the reference
        console.log("Abort signal sent.");
        // Note: setLoadingState(false) is handled in the finally block of handleGenerateClick
    } else {
        // console.log("No active generation request to cancel.");
    }
}

/** Clears content from the editor textareas. */
function clearEditors() {
    console.log("Clearing editor content...");
    if (DOM.htmlCodeArea) DOM.htmlCodeArea.value = '';
    if (DOM.cssCodeArea) DOM.cssCodeArea.value = '';
    if (DOM.jsCodeArea) DOM.jsCodeArea.value = '';
    // Optionally clear README too, or leave it
    // if (DOM.readmeArea) DOM.readmeArea.value = '';
    console.log("Editor content cleared.");
}

/** Populates editor fields and README with generated content. */
function populateEditors(result) {
    console.log("Populating editors with new content...");
    if (!result) {
        console.error("populateEditors called with null or undefined result.");
        return;
    }

    // Populate code editors
    if (DOM.htmlCodeArea) DOM.htmlCodeArea.value = result.html || '';
    if (DOM.cssCodeArea) DOM.cssCodeArea.value = result.css || '';
    if (DOM.jsCodeArea) DOM.jsCodeArea.value = result.js || '';

    // Update README content
    if (DOM.readmeArea) {
        const modelName = DOM.modelSelect?.selectedOptions[0]?.text || 'Selected Model';
        const providerName = DOM.providerSelect?.selectedOptions[0]?.text || 'Selected Provider';
        const generationDate = new Date().toLocaleString();

        // Simple Markdown template for README
        DOM.readmeArea.value = `# Project Details

**Generated using:** Code Starter AI
**Provider:** ${providerName}
**Model:** ${modelName}
**Generated on:** ${generationDate}

## Included Files:

*   \`index.html\` - Main structure
*   \`style.css\` - Styling rules
*   \`script.js\` - Client-side interactivity

---

*Please review the generated code for accuracy and security.*`;
    } else {
        console.warn("README textarea not found, cannot update README content.");
    }

    // Switch to the HTML tab by default after population
    setActiveTab('html-code');
    console.log("Editors populated and HTML tab activated.");

    // Trigger auto-resize for textareas in case content makes them smaller/larger initially
    autoResizePromptTextarea();
    // Could potentially add auto-resize for code editors if needed, but they usually fill space
}

/** Fetches available models from the backend and populates the dropdowns. */
async function fetchModelsAndPopulate() {
    console.log("Fetching available models...");
    if (!DOM.providerSelect || !DOM.modelSelect) {
        console.error("Cannot fetch models: Provider or Model select element not found.");
        return;
    }

    // Disable dropdowns and show loading state
    DOM.providerSelect.disabled = true;
    DOM.modelSelect.disabled = true;
    DOM.providerSelect.innerHTML = '<option value="">Loading Providers...</option>';
    DOM.modelSelect.innerHTML = '<option value="">(Select Provider)</option>'; // Clear previous models

    try {
        const response = await fetch("/api/models"); // Ensure this endpoint exists and returns the expected format
        if (!response.ok) {
            let errorDetail = `HTTP error ${response.status}`;
            try {
                const errorJson = await response.json();
                errorDetail = errorJson.error || errorDetail; // Use specific error message if provided
            } catch (_) {
                // If response is not JSON, try text
                try {
                    const errorText = await response.text();
                    if (errorText) errorDetail = errorText;
                } catch (__) { }
            }
            throw new Error(`Failed to load models: ${errorDetail}`);
        }

        AppState.availableModels = await response.json();
        console.log("Available models received:", AppState.availableModels);

        // Clear loading message
        DOM.providerSelect.innerHTML = '';

        // Get provider names and sort them
        const providerNames = Object.keys(AppState.availableModels).sort();

        if (providerNames.length === 0) {
            console.warn("No providers found in the received data.");
            DOM.providerSelect.innerHTML = '<option value="">No Providers Available</option>';
            DOM.modelSelect.innerHTML = '<option value="">N/A</option>';
            // Keep dropdowns disabled
            return; // Exit function early
        }

        // Add a default "Select" option
        const defaultOption = document.createElement("option");
        defaultOption.value = "";
        defaultOption.textContent = "Select Provider";
        defaultOption.disabled = true; // Make it non-selectable
        defaultOption.selected = true; // Make it the default display
        DOM.providerSelect.appendChild(defaultOption);


        // Populate provider dropdown
        providerNames.forEach(providerName => {
            const option = document.createElement("option");
            option.value = providerName;
            option.textContent = providerName;
            DOM.providerSelect.appendChild(option);
        });

        // Determine the first provider to potentially pre-select models for
        // Let's not pre-select a provider, force user selection
        // const firstProvider = providerNames[0];
        // DOM.providerSelect.value = firstProvider; // Pre-select the first provider
        // populateModelSelect(firstProvider); // Populate models for the pre-selected provider

        // Enable the provider dropdown now that it's populated
        DOM.providerSelect.disabled = false;
        console.log("Provider dropdown populated.");

    } catch (error) {
        console.error("Error fetching or processing models:", error);
        showError(error.message || "Could not load available models.");
        // Update dropdowns to show error state
        DOM.providerSelect.innerHTML = '<option value="">Error Loading</option>';
        DOM.modelSelect.innerHTML = '<option value="">Error</option>';
        // Keep them disabled
    }
}

/** Handles provider dropdown change events. */
function handleProviderChange() {
    if (!DOM.providerSelect) return;
    const selectedProvider = DOM.providerSelect.value;
    console.log(`Provider changed to: ${selectedProvider}`);
    if (selectedProvider) {
        populateModelSelect(selectedProvider);
    } else {
        // If user selects the "Select Provider" option
        DOM.modelSelect.innerHTML = '<option value="">(Select Provider)</option>';
        DOM.modelSelect.disabled = true;
    }
}

/** Populates the model dropdown based on the selected provider. */
function populateModelSelect(providerName) {
    if (!DOM.modelSelect) {
        console.error("Model select element not found.");
        return;
    }
    if (!AppState.availableModels) {
        console.error("Available models data is missing.");
        DOM.modelSelect.innerHTML = '<option value="">Error: Models data missing</option>';
        DOM.modelSelect.disabled = true;
        return;
    }
    if (!providerName) {
        // Should not happen if called from handleProviderChange with a value, but handle defensively
        console.log("populateModelSelect called with empty providerName.");
        DOM.modelSelect.innerHTML = '<option value="">(Select Provider)</option>';
        DOM.modelSelect.disabled = true;
        return;
    }

    const models = AppState.availableModels[providerName] || [];
    console.log(`Populating models for provider '${providerName}':`, models);

    // Clear existing model options
    DOM.modelSelect.innerHTML = "";
    DOM.modelSelect.disabled = true; // Disable initially

    if (models.length > 0) {
        let hasValidModels = false;
        let preSelected = false;

        // Add a default "Select" option
        const defaultOption = document.createElement("option");
        defaultOption.value = "";
        defaultOption.textContent = "Select Model";
        defaultOption.disabled = true;
        defaultOption.selected = true;
        DOM.modelSelect.appendChild(defaultOption);

        models.forEach(modelData => {
            // Check if modelData has the expected structure ({value: string, label: string, selected?: boolean})
            if (typeof modelData === 'object' && modelData !== null && modelData.value && modelData.label) {
                hasValidModels = true;
                const option = document.createElement("option");
                option.value = modelData.value;
                option.textContent = modelData.label;

                // Handle optional pre-selection
                if (modelData.selected === true && !preSelected) {
                    option.selected = true;
                    defaultOption.selected = false; // Unselect the default if we have a pre-selected one
                    preSelected = true; // Ensure only one is pre-selected
                }
                DOM.modelSelect.appendChild(option);
            } else {
                console.warn(`Skipping invalid model data for provider ${providerName}:`, modelData);
            }
        });

        if (hasValidModels) {
            DOM.modelSelect.disabled = false; // Enable if there are valid models
            console.log("Model dropdown populated and enabled.");
        } else {
            DOM.modelSelect.innerHTML = '<option value="">No Valid Models Found</option>';
            console.warn(`No valid models found for provider: ${providerName}`);
            // Keep disabled
        }
    } else {
        DOM.modelSelect.innerHTML = '<option value="">No Models Available</option>';
        console.warn(`No models listed for provider: ${providerName}`);
        // Keep disabled
    }
}

/** Updates the preview iframe with the current HTML, CSS, and JS content. */
function updatePreview() {
    if (!DOM.previewFrame) {
        console.warn("Preview frame not found, cannot update preview.");
        return;
    }
    // Avoid updating preview during initial state or if elements are missing
    if (AppState.isInitialState || !DOM.htmlCodeArea || !DOM.cssCodeArea || !DOM.jsCodeArea) {
        // console.log("Skipping preview update (initial state or missing elements).");
        return;
    }

    console.log("Updating preview frame...");

    const htmlContent = DOM.htmlCodeArea.value || "";
    const cssContent = (DOM.cssCodeArea.value || "").trim();
    const jsContent = (DOM.jsCodeArea.value || "").trim();

    // Basic styles to ensure preview content is visible and scrollable if needed
    const frameBaseStyles = `
        html, body {
            margin: 0;
            padding: 0;
            height: 100%; /* Ensure body can take height */
            width: 100%;
            overflow: auto !important; /* Allow scrolling within the frame */
            box-sizing: border-box;
            position: static !important; /* Override potential absolute positioning from user CSS */
        }
        *, *:before, *:after {
             box-sizing: inherit; /* Easier box model */
        }
    `;

    // Construct the full HTML document for the srcdoc
    let docContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preview</title>
    <style>${frameBaseStyles}</style>
`;
    // Inject user's CSS
    if (cssContent) {
        docContent += `    <style>${cssContent}</style>\n`;
    }
    docContent += `</head>
<body>
    ${htmlContent || "<!-- No HTML content yet -->"}
`;
    // Inject user's JS, wrapped in DOMContentLoaded and try-catch
    if (jsContent) {
        docContent += `
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            try {
                ${jsContent}
            } catch (e) {
                console.error("Error executing script in preview:", e);
                // Optionally display error in the preview itself
                // const errDiv = document.createElement('div');
                // errDiv.style.cssText = 'position:fixed;bottom:0;left:0;right:0;background:rgba(255,0,0,0.8);color:white;padding:5px;font-size:12px;z-index:9999;';
                // errDiv.textContent = 'JS Error: ' + e.message;
                // document.body.appendChild(errDiv);
            }
        });
    </script>
`;
    }
    docContent += `</body>
</html>`;

    try {
        // Setting srcdoc is generally safer than manipulating src with data URIs
        DOM.previewFrame.srcdoc = docContent;
        console.log("Preview frame updated successfully.");
    } catch (e) {
        console.error("Error setting preview frame srcdoc:", e);
        showError("Failed to update preview.");
        // Fallback: show an error message in the frame
        if (DOM.previewFrame) {
            DOM.previewFrame.srcdoc = `<html><body>Preview update failed. See console for details.</body></html>`;
        }
    }
}


/** Triggers a file download for the given content. */
function downloadFile(filename, content, mimeType) {
    if (content === null || content === undefined) {
        showError(`Cannot download "${filename}": No content available.`);
        console.warn(`Attempted to download "${filename}" but content was null or undefined.`);
        return;
    }

    console.log(`Preparing download for: ${filename} (MIME: ${mimeType})`);

    try {
        // Create a Blob from the content
        const blob = (content instanceof Blob) ? content : new Blob([content], { type: mimeType });

        // Create a temporary URL for the Blob
        const url = URL.createObjectURL(blob);

        // Create a temporary anchor element
        const a = document.createElement('a');
        a.href = url;
        a.download = filename; // Set the desired filename
        a.style.display = 'none'; // Make it invisible

        // Append the anchor to the body, click it, and remove it
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        // Revoke the temporary URL to free up memory
        URL.revokeObjectURL(url);

        console.log(`Download triggered successfully for: ${filename}`);
    } catch (error) {
        console.error(`Error creating download for ${filename}:`, error);
        showError(`Failed to initiate download for "${filename}".`);
    }
}

/** Creates and downloads a ZIP archive of the project files. */
async function handleDownloadZip() {
    if (typeof JSZip === 'undefined') {
        showError('Cannot create ZIP: JSZip library is not loaded.');
        console.error("handleDownloadZip called but JSZip is undefined.");
        return;
    }
    if (!DOM.htmlCodeArea || !DOM.cssCodeArea || !DOM.jsCodeArea || !DOM.readmeArea) {
        showError('Cannot create ZIP: One or more code areas are missing.');
        console.error("handleDownloadZip called but required DOM elements are missing.");
        return;
    }

    console.log("Creating ZIP archive...");
    setDownloadButtonState(true); // Indicate zipping in progress

    try {
        const zip = new JSZip();

        // Get content from textareas
        const htmlContent = DOM.htmlCodeArea.value;
        const cssContent = DOM.cssCodeArea.value;
        const jsContent = DOM.jsCodeArea.value;
        const readmeContent = DOM.readmeArea.value || AppState.readmeContent; // Use default if empty

        // Add files to the zip, only if they have content (optional check)
        // You might always want to include the file even if empty.
        if (htmlContent) zip.file("index.html", htmlContent);
        else zip.file("index.html", "<!-- Empty HTML file -->"); // Add empty placeholder

        if (cssContent) zip.file("style.css", cssContent);
        else zip.file("style.css", "/* Empty CSS file */");

        if (jsContent) zip.file("script.js", jsContent);
        else zip.file("script.js", "// Empty JS file");

        if (readmeContent) zip.file("README.md", readmeContent);

        // Check if any files were actually added (adjust based on placeholder decision)
        if (Object.keys(zip.files).length === 0) {
            // This condition might not be reachable if placeholders are always added
            throw new Error("No content available to include in the ZIP file.");
        }

        // Generate the ZIP file as a Blob
        console.log("Generating ZIP blob...");
        const blob = await zip.generateAsync({
            type: "blob",
            compression: "DEFLATE", // Standard compression
            compressionOptions: {
                level: 6 // Compression level (1-9), 6 is a good default
            }
        });
        console.log("ZIP blob generated.");

        // Trigger the download
        const timestamp = new Date().toISOString().replace(/[:.-]/g, '').slice(0, 15); // e.g., 20231027T103000Z
        const zipFilename = `code-starter-project-${timestamp}.zip`;
        downloadFile(zipFilename, blob, "application/zip");

    } catch (error) {
        console.error("Error creating or downloading ZIP file:", error);
        showError(`Failed to create ZIP: ${error.message}`);
    } finally {
        // Always reset the button state, whether success or failure
        setDownloadButtonState(false);
        console.log("ZIP creation process finished.");
    }
}

/** Returns whether the document is currently in fullscreen mode. */
function isFullscreenActive() {
    // Check across vendor prefixes
    return !!(
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.mozFullScreenElement ||
        document.msFullscreenElement
    );
}

/** Toggles fullscreen mode for the preview pane. */
function toggleFullScreenPreview() {
    if (!DOM.previewPane) {
        console.error("Cannot toggle fullscreen: Preview pane element not found.");
        showError("Internal error: Preview pane missing.");
        return;
    }

    if (!isFullscreenActive()) {
        // Enter fullscreen
        console.log("Requesting fullscreen for preview pane...");
        const requestMethod =
            DOM.previewPane.requestFullscreen ||
            DOM.previewPane.webkitRequestFullscreen ||
            DOM.previewPane.mozRequestFullScreen || // Note 'S'
            DOM.previewPane.msRequestFullscreen;

        if (requestMethod) {
            requestMethod.call(DOM.previewPane)
                .then(() => console.log("Entered fullscreen successfully."))
                .catch(err => {
                    console.error("Error attempting to enable fullscreen:", err);
                    showError(`Could not enter fullscreen: ${err.message}`);
                });
        } else {
            console.warn("Fullscreen API is not supported by this browser.");
            showError("Fullscreen mode is not supported by your browser.");
        }
    } else {
        // Exit fullscreen
        console.log("Exiting fullscreen...");
        const exitMethod =
            document.exitFullscreen ||
            document.webkitExitFullscreen ||
            document.mozCancelFullScreen || // Note 'Cancel' and 'S'
            document.msExitFullscreen;

        if (exitMethod) {
            exitMethod.call(document)
                .then(() => console.log("Exited fullscreen successfully."))
                .catch(err => {
                    // This catch might not always trigger depending on browser implementation
                    console.error("Error attempting to disable fullscreen:", err);
                    // Don't usually show error to user on exit failure
                });
        } else {
            // This case is less likely if entering worked, but handle defensively
            console.warn("Exit fullscreen method not found.");
        }
    }
}

/** Handles changes in fullscreen mode (browser event). */
function handleFullscreenChange() {
    const currentlyFullscreen = isFullscreenActive();
    console.log(`Fullscreen state changed. Active: ${currentlyFullscreen}`);

    // Toggle a class on the body or a container to apply specific styles
    DOM.body?.classList.toggle('fullscreen-preview-active', currentlyFullscreen);

    // Update the button icon and title
    updateFullscreenButtonVisuals();
}

/** Updates the visuals (icon, title) of the fullscreen toggle button. */
function updateFullscreenButtonVisuals() {
    if (!DOM.fullscreenButton || !DOM.fsIconExpand || !DOM.fsIconCollapse) {
        // Don't log error here, as elements might be optional or missing initially
        return;
    }
    const active = isFullscreenActive();

    // Toggle visibility of expand/collapse icons
    DOM.fsIconExpand.classList.toggle('hidden', active);
    DOM.fsIconCollapse.classList.toggle('hidden', !active);

    // Update button title for accessibility and tooltips
    DOM.fullscreenButton.title = active ? "Exit Fullscreen Preview" : "Enter Fullscreen Preview";
}

/**
 * Toggles the UI loading state.
 * Disables/enables input elements and shows/hides the loading indicator.
 */
function setLoadingState(isLoading) {
    console.log(`Setting loading state: ${isLoading}`);
    AppState.isLoading = isLoading;

    // Toggle loading indicator visibility
    DOM.loadingIndicator?.classList.toggle('hidden', !isLoading);

    // Add/remove loading class from body (for potential global styles like cursor)
    DOM.body?.classList.toggle('loading-active', isLoading);

    // Set aria-busy attribute for accessibility on the main content area
    DOM.mainContentArea?.setAttribute('aria-busy', isLoading.toString());

    // Enable/disable interactive elements
    const shouldDisable = isLoading;
    console.log(`Updating element disabled state to: ${shouldDisable}`);

    // List of elements to disable/enable
    const elementsToToggle = [
        DOM.promptInput,
        DOM.generateButton,
        DOM.providerSelect,
        DOM.modelSelect, // Model select might already be disabled if no provider is selected
        // Add other controls if needed, e.g., configuration buttons
    ];

    elementsToToggle.forEach((el, index) => {
        if (el) {
            // Special handling for modelSelect: only disable if isLoading is true,
            // but don't re-enable it if the providerSelect is still not selected.
            if (el === DOM.modelSelect) {
                el.disabled = shouldDisable || !DOM.providerSelect?.value;
            } else {
                el.disabled = shouldDisable;
            }

            // Optional: Add/remove a visual style for disabled state if needed beyond default browser styles
            el.style.opacity = shouldDisable ? '0.7' : '1';
            el.style.cursor = shouldDisable ? 'not-allowed' : '';
        } else {
            // Log missing elements during this phase too, helps debugging if cache failed silently
            // console.warn(`Element at index ${index} is missing in setLoadingState.`);
        }
    });

    // Disable/enable all download buttons collectively
    setDownloadButtonState(shouldDisable);


    // Hide error message when loading starts
    if (isLoading) {
        hideError();
    }

    console.log(`Loading state set to ${isLoading}. Inputs disabled: ${shouldDisable}`);
}


/** Displays an error message in the designated UI element. */
function showError(message) {
    let displayMsg = "An unexpected error occurred."; // Default message

    // Determine the message string
    if (typeof message === 'string' && message.trim() !== '') {
        displayMsg = message.trim();
    } else if (message instanceof Error) {
        displayMsg = message.message || displayMsg; // Use error message if available
    } else if (message) {
        // Try converting other types to string, but be cautious
        try {
            const strMsg = message.toString();
            if (strMsg && strMsg !== '[object Object]') { // Avoid generic object string
                displayMsg = strMsg;
            }
        } catch (e) { /* Ignore conversion errors */ }
    }

    console.error("Displaying Error:", displayMsg); // Log the actual error shown to user

    if (DOM.errorMessageDiv) {
        DOM.errorMessageDiv.textContent = displayMsg;
        DOM.errorMessageDiv.classList.remove('hidden'); // Make it visible
        // Optional: Add role="alert" dynamically if not set in HTML for screen readers
        DOM.errorMessageDiv.setAttribute('role', 'alert');
    } else {
        // Fallback if the dedicated error div isn't found
        console.error("Error message div (#error-message) not found! Using alert as fallback.");
        alert(`Error: ${displayMsg}`);
    }

    // Optional: Automatically hide the error after a delay
    // clearTimeout(AppState.errorTimeout); // Clear previous timeout if any
    // AppState.errorTimeout = setTimeout(hideError, 7000); // Hide after 7 seconds
}


/** Hides the error message display. */
function hideError() {
    if (DOM.errorMessageDiv) {
        DOM.errorMessageDiv.classList.add('hidden');
        DOM.errorMessageDiv.textContent = ''; // Clear text content
        // Optional: Remove role="alert" when hidden
        DOM.errorMessageDiv.removeAttribute('role');
        // console.log("Error message hidden.");
    }
    // Clear any auto-hide timeout
    // clearTimeout(AppState.errorTimeout);
}

/** Enables or disables all download buttons, handling ZIP button separately. */
function setDownloadButtonState(disabled) {
    // console.log(`Setting download button disabled state: ${disabled}`);
    DOM.allDownloadButtons?.forEach(button => {
        // Always disable the ZIP button if JSZip is missing, regardless of the 'disabled' argument
        if (button === DOM.downloadZipButton && typeof JSZip === 'undefined') {
            if (!button.disabled) { // Only log if state changes
                console.warn("ZIP button forced disabled because JSZip is missing.");
                button.disabled = true;
                button.style.opacity = '0.6';
                button.style.cursor = 'not-allowed';
                button.title = "ZIP functionality unavailable (library missing)";
            }
            return; // Skip further processing for the ZIP button in this case
        }

        // Apply the general disabled state
        if (button.disabled !== disabled) { // Only update if state actually changes
            button.disabled = disabled;
            button.style.opacity = disabled ? '0.6' : '1';
            button.style.cursor = disabled ? 'not-allowed' : 'pointer';
        }

        // Special handling for ZIP button text/icon during ZIP generation
        if (button === DOM.downloadZipButton && typeof JSZip !== 'undefined') {
            // Update ZIP button content only if it's the one being actively processed (handled in handleDownloadZip)
            // This function just handles the general enable/disable state.
            // The specific "Zipping..." state is managed in handleDownloadZip.
            if (!disabled) {
                // Restore original content when enabling
                button.innerHTML = `<i class="fas fa-file-archive"></i> ZIP`;
                button.title = "Download project as ZIP file";
            }
            // else: Don't overwrite if it's currently showing "Zipping..."
        }
    });
}

/**
 * Creates a debounced version of a function.
 * Delays invoking the function until after 'wait' milliseconds have elapsed
 * since the last time the debounced function was invoked.
 * @param {Function} func - The function to debounce.
 * @param {number} wait - The number of milliseconds to delay.
 * @returns {Function} The new debounced function.
 */
function debounce(func, wait) {
    let timeoutId = null;

    // Return a function that wraps the original function
    return function (...args) {
        // Capture the context (`this`) and arguments of the call
        const context = this;

        // Clear the existing timeout (if any)
        clearTimeout(timeoutId);

        // Set a new timeout to execute the original function after the wait period
        timeoutId = setTimeout(() => {
            // Reset timeoutId so future calls aren't blocked unnecessarily
            timeoutId = null;
            // Call the original function with the saved context and arguments
            func.apply(context, args);
        }, wait);
    };
}

// --- End of script.js ---